// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_CODE_FOR_ZK_PROOF_ELF, GUEST_CODE_FOR_ZK_PROOF_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use host::MerkleTree;
use core::{ClaimInput, ClaimOutput, PublicInputs};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    println!("=== ZK Airdrop - Phase 2 Demo ===\n");

    // Step 1: Create eligibility list (sample addresses)
    let eligible_addresses = vec![
        [1u8; 20],
        [2u8; 20],
        [3u8; 20],
        [4u8; 20],
    ];

    println!("Created eligibility list with {} addresses", eligible_addresses.len());

    // Step 2: Build Merkle tree
    let tree = MerkleTree::new(&eligible_addresses);
    let root = tree.root();
    println!("Merkle root: 0x{}", hex::encode(root));

    // Step 3: User wants to claim (let's say user at index 2)
    let user_index = 2;
    let user_address = eligible_addresses[user_index];
    let merkle_proof = tree.get_proof(user_index);

    println!("\nUser claiming:");
    println!("  Address: 0x{}", hex::encode(user_address));
    println!("  Index: {}", user_index);
    println!("  Proof length: {}", merkle_proof.len());

    // Step 4: Create claim input (private data)
    let epoch_id = 1u64;
    let claim_input = ClaimInput {
        user_address,
        merkle_proof,
        leaf_index: user_index as u32,
        epoch_id,
    };

    // Step 5: Create public inputs
    let public_inputs = PublicInputs {
        merkle_root: root,
        epoch_id,
    };

    println!("\nGenerating proof...");

    // Step 6: Build executor environment
    let env = ExecutorEnv::builder()
        .write(&claim_input)
        .unwrap()
        .write(&public_inputs)
        .unwrap()
        .build()
        .unwrap();

    // Step 7: Generate proof
    let prover = default_prover();
    let prove_info = prover.prove(env, GUEST_CODE_FOR_ZK_PROOF_ELF).unwrap();
    let receipt = prove_info.receipt;

    println!("✓ Proof generated successfully!");

    // Step 8: Extract and verify output
    let output: ClaimOutput = receipt.journal.decode().unwrap();

    println!("\nProof output:");
    println!("  Verified root: 0x{}", hex::encode(output.merkle_root));
    println!("  Nullifier: 0x{}", hex::encode(output.nullifier));
    println!("  Epoch: {}", output.epoch_id);

    // Step 9: Verify the receipt
    receipt.verify(GUEST_CODE_FOR_ZK_PROOF_ID).unwrap();
    println!("\n✓ Receipt verified successfully!");

    // Step 10: Verify output matches expected values
    assert_eq!(output.merkle_root, root, "Root mismatch");
    assert_eq!(output.epoch_id, epoch_id, "Epoch mismatch");

    println!("\n=== Phase 2 Complete! ===");
    println!("✓ Merkle tree built");
    println!("✓ Proof generated");
    println!("✓ Proof verified");
    println!("✓ Nullifier computed");
}

// Helper module for hex encoding
mod hex {
    pub fn encode(bytes: impl AsRef<[u8]>) -> String {
        bytes
            .as_ref()
            .iter()
            .map(|b| format!("{:02x}", b))
            .collect()
    }
}
